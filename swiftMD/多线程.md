1. 串行队列：等待现在执行中的处理结果；并行队列：不等待在执行中的处理结果。

2. 多个线程更新相同资源导致数据竞争时使用**同步队列**。

3. 当想并行执行不发生数据竞争等问题的处理时，用**并行队列**。

   > 写入不能并行，读取可以。

4. 派遣组：在追加到派遣队列中的多个处理全部结束后想执行结束处理。

5. Dispatch barrier async会等待追加到队列上的并行执行的处理全部结束后，再将指定的处理追加到该队列中，然后函数追加的处理结束后，队列才恢复动作，队列又开始并行执行。

6. 死锁：使用同步等待执行处理的API，等待执行。

7. Dispatch apply：按照指定次数将闭包追加到指定的派遣队列中。

8. suspend挂起&resume恢复。

9. UI优先级最高，后台最低。

10. Semaphore信息量：持有计数的信号，计数为0时等待，计数大于等于1时不等待。（比如可以设置同时执行的任务的数量）

11. Operations：

12. 系统预设的优先级有六个。

    > #### `.userInteractive`
    >
    > 这个级别的任务设计为处理直接与用户交互相关的任务。比如界面更新计算，动画等。
    > 如果这个任务不马上完成，用户界面看起来就会卡住。所以提交到这个队列任务需要立即完成.
    >
    > #### `.userInitiated`
    >
    > 这个级别的任务设计为处理需要立即发生但是可以异步完成。比如从用户点击查看一个文档，或者从本地数据库读取信息等。
    > 这里的任务也期望短时间或几秒内迅速完成。
    >
    > ####  `.default`
    >
    > 这个选项是默认值，是作为没有明确设定优先级的时候的缺省值。最好给每个任务都设定一个级别而不是使用这个值。
    >
    > ####  `.utility`
    >
    > 这个级别的任务设计为用于长时间运行的计算等。比如联网或连续数据馈送。
    > 任务会在响应速度和性能与能源效率之间取得平衡。这里的任务可能需要几秒钟到几分钟。
    >
    > ####  `.background`
    >
    > 这个级别的任务设计为用于花费长时间并且用户不在乎它什么时候完成的。比如数据库维护，同步远程服务器和备份。
    > 这里的任务将专注于能源效率而不是速度，那些用大量时间(几分钟或更长)的工作应该放这里。
    >
    > ####  `.unspecified`
    >
    > 这个选项是用于兼容旧版API，因为有些旧版API可能会使线程超出QoS范围。所以不要使用这个值。

13. 线程依赖：

    > 1. 使用线程组，监听任务是否完成。
    > 2. 使用operation，设置依赖。
    > 3. 使用信息量。

问题：

1. 资源竞争：串行访问、DispatchQueue().async(flags: .barrier)
2. **无法确定队列中的任务最终会被分配到哪个线程**，所以在你创建了一个自定义队列然后添加同步任务的时候，这个同步任务可能还是在主线程执行。而此时如果在这个自定义队列里`DispatchQueue.main.sync(){}`就会造成死锁
3. 