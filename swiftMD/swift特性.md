1. 类型：变量和常量有数据类型，根据类型编译器进行类型检查，这是 Swift的一个特性，可以防止你错误的把其他类型的数据赋值给一个变量。Swift用类型推断(type inference)确定变量的数据类型。

2. 数：

   > 溢出加操作符：&+
   >
   > 

3. 元组：

   > ```swift
   > let error = (code: statusCode, error: errorString)
   >     error.code
   >     error.error
   > ```

4. 可空实例绑定

   > 对于判断可空实例是否有值很有用。如 果有值，就将其赋给一个临时常量或变量，并且使这个常量或变量在条件语句的第一个分支代码中可用。

5. 结构体（结构体和枚举都是值类型，需要在能修改实例属性的方法前加上mutating关键字。）

   > **mutating 方法**：如果结构体的一个实例方法要修改结构体的属性，就必须标记为mutating。
   >
   > **Static 关键字**：类型本身进行调用的方法，我们称之为类型方法。

6. 类

   > 类的一个重要特性是**继承**。
   >
   > **super**是一个前缀，用来访问父类的方法实现。
   >
   > 包括结构体在内的值类型在传递时总是会被复制。
   >
   > **Final关键字**：让方法或属性不可重写。
   >
   > **Class关键字**：类型本身进行调用的方法，我们称之为类型方法。类型方法不能调用实例方法，也不能用实例属性。这是因为实例不能在类型级别使用。**final class关键字**：告诉编译器不要让子类为方法提供自己的实现。

7. 属性

   > 1. 存储属性：
   >
   >    > 你既可以从属性中读取值，也可以给属性设置值。
   >    >
   >    > lazy：这种延迟把属性的值的计算推迟到实例初始化后。
   >    >
   >    > 存储类型属性必须有默认值。
   >
   > 2. 计算属性：
   >
   >    > 计算属性不会像之前的属性那样存储值，而是提供一个读取方法(getter)来获取属性的值，并可选地提供一个写入方法(setter)设置属性的值。这个区别能让计算属性的值发生变化，不像惰性存储属性的值那样无法变化。
   >    >
   >    > 需要显式地声明计算属性的类型

8. 初始化

   > 1. 结构体和类的存储属性在初始化完成的时候需要有初始值。
   > 2. 指定(designated)初始化：指定初始化方法负责确保初始化完成前所有的属性都有值，以 便实例可用。
   > 3. 便捷(convenience)初始化：便捷初始化方法是指定初始化方法的补充，通过调用所在类的指定初始化方法来实现，主要作用通常是为某种特殊目的创建实例。
   > 4. 反初始化(deinitialization)是在类的实例没用之后将其清除出内存的过程。

9. 值类型和引用类型

   > 1. 值类型：
   >
   >    > 在被赋给另一个实例或是作为参数传递给函数时，值类型总是被复制。它们没有指向同一个实例。
   >    >
   >    > Swift的基本类型(Array、Dictionary、Int、String等)都是用结构体实现的，都是值类型。尽量优先用struct实现数据建模，只有在需要的时候才用class。
   >
   > 2. 引用语义：
   >
   >    > 赋值操作会对底层实例创建新的引用。
   >    >
   >    > 对于引用来说，常量或变量都指向内存中的同一个实例。
   >
   > 3. 值类型常量和引用类型常量
   >
   >    > 声明为常量的值类型不能改变属性，即使属性在类型实现中是用var声明的也是一样。
   >    >
   >    > 声明为常量的引用类型可以改变属性。
   >    >
   >    > 为什么不能改变声明为常量的值类型实例的属性，却能改变声明为常量的引用类型实例的属性？	答：当修改属性值时，修改的是类指向的实例，只要是可变存储属性就可以任意修改。
   >    >
   >    > 在值类型内使用引用类型时要务必小心。(在引用类型内使用值类型倒不会有什么问题)
   >
   > 4. 浅复制
   >
   >    > 浅复制不会创建实例的不同副本，而是复制这个实例的引用。
   >
   > 5. 深复制
   >
   >    > 深复制会复制引用指向的目标。
   >
   > 6. 选用类还是结构体
   >
   >    > 如果类型需要传值，那就用结构体。这么做会确保赋值或传递到函数参数中时类型被 复制。
   >    >
   >    > 如果类型不支持子类继承，那就用结构体。结构体不支持继承，所以不能有子类。
   >    >
   >    > 如果类型要表达的行为相对比较直观，而且包含一些简单值，那么考虑优先用结构体实 现。
   >    >
   >    > 其他所有情况都用类。定义数据结构，
   >
   > 7. 写时复制
   >
   >    > 写时复制(copy on write，COW)是指对值类型的底层存储的隐式共享。这种优化能够让某个值类型的多个实例共享同一个底层存储，也就是每个实例自己并不持有一份数据的副本；反之，每个实例会维护自己对同一份存储的引用。

10. 协议：协议可以让你无需知道类型本身的信息，就能指定并利用类型的接口(interface)。 接口是类型提供的一组属性和方法。

    > 1. 符合协议
    >
    >    > 结构体，类，枚举都可以符合协议。
    >
    > 2. 协议继承

11. 错误处理

    > 1. assert：
    >
    >    > 1. assert(\_:\_:)的第一个参数是要检查的条件。如果条件计算为true，什么都不会发生。不过，如果条件计算为false，程序就会触发陷阱，进入调试器，显示第二个参数提供的消息。
    >    > 2. assert用来捕获不可恢复的错误的工具。
    >
    > 2. throw：
    >
    >    > 在Swift中，用throw关键字来发送(抛出)错误给调用者。
    >    >
    >    > 必须抛出符合Error协议的类型的实例。
    >
    > 3. do/catch：
    >
    >    > 在do语句块的最后要写一个catch语句块。如果do语句块中的任意一个try调用抛出错误， catch语句块就会运行，并且会把抛出的错误定到常量error上。可以再添加一个catch 语句块捕获某类错误。

12. 拓展

    > 1. Swift拓展不允许为类型添加存储属性，可以添加计算属性。

13. 范型

    > Swift范型(generics)让我们写出的类型和函数可以使用对于我们或编译器都未知的类型。
    >
    > Swift声明范型的语法是在类型名后面紧跟尖括号(<>)。尖括号内的名字表示占位类型:<Element>。
    >
    > 1. 类型约束：一种是类型必须是给定类的子类，还有一种是类型必须符合一个协议(或者一个协议组合)

14. 内存分配

    > Swift不像C那样需要手动管理内存，而是为每个类实例维护一个引用计数(reference count)。 这是对组成类实例的内存的引用数量。只要引用计数大于0，实例就会存活。一旦引用计数变成0， 实例就会被回收，deinit方法运行。
    >
    > 1. 循环强引用(strong reference cycle)
    >
    >    > A引用B， B引用A，当A实例无法被引用了，但是内存不会被回收，因为每个实例的引用计数都大于0。循环强引用就是一种内存泄漏(memory leak)。应用分配了足够Bob和其资产所需的内存，但是当程序不再需要这些内存后并没有将其还给系统。
    >
    > 2. 弱引用：
    >
    >    > 弱引用不增加所指向实例的引用计数。
    >    >
    >    > 弱引用必须用var声明，不能用let。
    >    >
    >    > 弱引用必须声明为可空类型。
    >
    > 3. 闭包中的循环强引用：
    >
    >    > 闭包能捕获在闭合作用域中定义的变量。默认情况下，闭包的捕获是通过对用到的变量的强引用实现的。
    >    >
    >    > Swift本来可以显式地在闭包中使用self，但是这么做很容易不小心造成循环引用，如上面这个例子一样。因此， Swift通常需要我们显式地使用self，强迫我们考虑发生循环引用的可能性。
    >    >
    >    > 要改变闭包的捕获语义，使捕获变成弱引用。（[weak self]）

15. Equatable 和 Comparable

16. 闭包：

    > 1. 形参列表中的形参不能有默认值。
    > 2. 闭包中的引用循环。
    > 3. 闭包可以在其定义的上下文中捕获常量或变量。
    > 4. Swift还支持不可能产生循环强引用的闭包。这类闭包被称为非逃逸闭包(non-escaping closure)，不需要显式调用self。
    > 5. 逃逸表示传递给一个函数的闭包可能会在该函数返回后被调用。也就是说，闭包逃脱出了接收它作为参数的函数的作用域。